<!DOCTYPE html>
<html>
<head>
    <title>Vector Initial Static Map</title>
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script
            src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAVuTX2xVdm8OScLSE8kVWr-jP4L2582mw&libraries=geometry,places&callback=initMap&v=beta"
            async defer>
    </script>

    <script>
        (function (exports) {
            var map;
            var curr_pos;
            var current_marker;
            var pos = { lat: '',lng: ''};

            var directionsService;
            var directionsRenderer;
            var searchMarker;

            let currentStepIndex = 0; // Track the current step index
            const steps = []; // Store steps of the route
            const mockLocationData = []; 


            var car = "M17.402,0H5.643C2.526,0,0,3.467,0,6.584v34.804c0,3.116,2.526,5.644,5.643,5.644h11.759c3.116,0,5.644-2.527,5.644-5.644 V6.584C23.044,3.467,20.518,0,17.402,0z M22.057,14.188v11.665l-2.729,0.351v-4.806L22.057,14.188z M20.625,10.773 c-1.016,3.9-2.219,8.51-2.219,8.51H4.638l-2.222-8.51C2.417,10.773,11.3,7.755,20.625,10.773z M3.748,21.713v4.492l-2.73-0.349 V14.502L3.748,21.713z M1.018,37.938V27.579l2.73,0.343v8.196L1.018,37.938z M2.575,40.882l2.218-3.336h13.771l2.219,3.336H2.575z M19.328,35.805v-7.872l2.729-0.355v10.048L19.328,35.805z";
            var icon = {
            path: car,
            scale: .7,
            strokeColor: 'white',
            strokeWeight: .10,
            fillOpacity: 1,
            fillColor: '#404040',
            offset: '5%',
         
    
            };
           
            function initMap() {
               displayMap();
               initSearch();
            }

            function initSearch(){
                
                const input = document.getElementById("pac-input");
                const searchBox = new google.maps.places.SearchBox(input);


                searchBox.addListener("places_changed", () => {
                    const places = searchBox.getPlaces();
                    const bounds = new google.maps.LatLngBounds();
                    console.log(places[0]);

                    if(searchMarker!=null){
                        searchMarker.setMap(null);
                    }
                   
                    if (places.length == 0) {
                    return;
                    }else{
                    
                        if (places[0].geometry.viewport) {
                                // Only geocodes have viewport.
                                bounds.union(places[0].geometry.viewport);
                            } else {
                                bounds.extend(places[0].geometry.location);
                            }

                        searchMarker = new google.maps.Marker({
                            map,
                            title:places[0].name,
                            position: places[0].geometry.location,
                          
                        });
                        map.setCenter(searchMarker.getPosition())
                        // map.fitBounds(bounds);
                        map.setZoom(18);
                        map.setTilt(60);
                        map.setHeading(320);
                       
                    }

                    // Clear out the old markers.
                    // markers.forEach((marker) => {
                    // marker.setMap(null);
                    // });
                });
            }

            function displayMap() {
              map = new google.maps.Map(document.getElementById("map"), {
                center: { lat: 51.503399, lng: -0.119519 },
                    zoom: 17,
                    heading: 320,
                    tilt: 50,
                    mapId: "7c913e398bf72d2d",
                    disableDefaultUI: true,

                });
               // getLocation();
            }

            function getLocation(){

                if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                    curr_pos = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                        };

                        var marker = new google.maps.Marker({
                            position:curr_pos,
                          
                        });
                        marker.setMap(map);
                        map.setCenter(curr_pos);
                        map.setZoom(17);
                        map.setTilt(60);

                        current_marker = marker
                    });

                }

               // setTimeout(getDirection,2000)

            }

            function getDirection() {

                directionsRenderer = new google.maps.DirectionsRenderer();
                directionsService = new google.maps.DirectionsService();
                directionsRenderer.setOptions({
                    polylineOptions: {
                        strokeColor: 'blue',
                        strokeWeight: 6
                    }
                });
                directionsRenderer.setMap(map);

                // const start = new google.maps.LatLng(pos.lat,pos.lng);


                const start = "RoyalEnfield HQ, Sholinganallur, Elcot SEZ, Chennai";

                const end = "BSR Mall, Chennai";

                //  const start = "Londen Eye"
                //  const end = "Buckinghum Palace, London"

                directionsService.route({
                    origin: start,
                    destination: end,
                    travelMode: google.maps.TravelMode.DRIVING,
                }, (response, status) => {
                    if (status === google.maps.DirectionsStatus.OK) {
                        directionsRenderer.setDirections(response);
                        console.log(response.routes[0])

                        const route = response.routes[0];
                        const leg = route.legs[0];
                        steps.push(...leg.steps);

                        console.log("Step length --> "+ steps.length);

                        mockLocationData.push(...route.overview_path);

                        curr_pos = mockLocationData[0];

                        updateInstructions(currentStepIndex);

                    } else {
                        console.error("Directions request failed due to " + status);
                    }
                });

                 setTimeout(animateMarker,3000)
            }

            function animateMarker() {

                var targetPosition = null;
                var isAnimating = false;
                var animationDuration = 1000;
                const cameraOffsetDistance = 20;
                const markerOffsetFactor = 0.3;
                var count = 0;


                 function goToPoint() {

                    var lastBearing = 0;
                    if (!targetPosition || isAnimating) return;

                    isAnimating = true;
                    var currentPosition = curr_pos;

                    var distance = google.maps.geometry.spherical.computeDistanceBetween(currentPosition, targetPosition);
                    var bearing = google.maps.geometry.spherical.computeHeading(currentPosition, targetPosition);

                    var startTime = Date.now();
                    var endTime = startTime + animationDuration;

                    var easingFactor = 0.1;
                    var newBearing = lastBearing + (bearing - lastBearing) * easingFactor;
                    lastBearing = newBearing;

                    icon.rotation = newBearing;
                    current_marker.setIcon(icon);

                    var animationInterval = setInterval(function() {
                        var elapsed = Date.now() - startTime;
                        if (elapsed > animationDuration) {
                            clearInterval(animationInterval);
                            current_marker.setPosition(targetPosition);
                            curr_pos = targetPosition;
                            isAnimating = false;
                            return;
                        }

                        var t = elapsed / animationDuration;
                        var interpolatedPosition = google.maps.geometry.spherical.interpolate(
                            curr_pos,
                            targetPosition,
                            t
                        );
                        current_marker.setPosition(interpolatedPosition);
                        updateCameraPosition(current_marker.getPosition(),bearing);

                    }, 150); // Adjust interval for smoother animation (e.g., 20ms)
                }

                 function updateCameraPosition(position, heading) {
                    // Calculate the offset position behind the marker
                    const offsetDistance = cameraOffsetDistance; //0.5
                    const headingRad = (heading + 180) * Math.PI / 180; // Reverse the heading to get behind the marker
                    const offsetLat = position.lat() + (Math.sin(headingRad) * offsetDistance / 111111); // 111111 meters per degree latitude
                    const offsetLng = position.lng() + (Math.cos(headingRad) * offsetDistance / (111111 * Math.cos(position.lat() * Math.PI / 180))); // Adjust for longitude

                    const cameraPosition = new google.maps.LatLng(offsetLat, offsetLng);

                // Adjust the camera position to account for the desired marker offset from the bottom

                     //const zoomFactor = Math.pow(2, map.getZoom()); // Scale the offset based on zoom level
                     //const worldCoord = map.getProjection().fromLatLngToPoint(position);
                     //const markerOffsetPixels = map.getDiv().offsetHeight * markerOffsetFactor;
                     //const offsetWorldCoord = new google.maps.Point(worldCoord.x, worldCoord.y - markerOffsetPixels / (256 * zoomFactor));
                     //const adjustedLatLng = map.getProjection().fromPointToLatLng(offsetWorldCoord);

                 // Calculate the vertical offset in pixels
                    const offsetPixels = map.getDiv().offsetHeight * markerOffsetFactor;
                    const scale = Math.pow(2, map.getZoom());
                    const offsetLatDegrees = (offsetPixels / scale) / 256 * 360; // Convert pixels to degrees latitude

                    // Adjust the map center to move the marker towards the bottom
                    const adjustedLat = position.lat() - offsetLatDegrees / (111111 * Math.cos(position.lat() * Math.PI / 180));

                    const adjustedPosition = new google.maps.LatLng(adjustedLat, position.lng());


                    // Set the map's center to the calculated position
                    map.setCenter(adjustedPosition);
                    map.setHeading(heading); // Rotate the map to match the user's heading
                    map.setZoom(18);
                    map.setTilt(50); // Optional: Adjust tilt for a better following view
                }

                // Callback to update the target location
                // function updateLocation(){
                //     if (navigator.geolocation) {
                //         navigator.geolocation.getCurrentPosition(
                //             (position) => {
                //                 targetPosition = {
                //                 lat: position.coords.latitude,
                //                 lng: position.coords.longitude,
                //                 };

                //                 goToPoint();
                //                 updateCurrentStep(targetPosition)

                //             });
                // }
                // }


                function mockLocation(){
                    
                    if(count >= mockLocationData.length) return;

                    targetPosition = {
                        lat: mockLocationData[count].lat(),
                        lng: mockLocationData[count].lng(),
                    };
                       
                    goToPoint();
                    updateCurrentStep(targetPosition);
                    count++;
                }


                
                setInterval(mockLocation,2000)

            }
            

            function updateCurrentStep(currentCoords) {
               
                if (currentStepIndex >= steps.length) return; // No more steps
            
                const step = steps[currentStepIndex];
                const nextStep = (currentStepIndex + 1 < steps.length) ? steps[currentStepIndex + 1] : null; 
                const nextNextStep = (currentStepIndex + 2 < steps.length) ? steps[currentStepIndex + 2] : null; 
                // if(currentStepIndex != 0)
                //      next_step = steps[currentStepIndex+1];
                     

                const stepStart = {
                    lat: step.start_location.lat(),
                    lng: step.start_location.lng()
                };

                const stepEnd = {
                    lat: step.end_location.lat(),
                    lng: step.end_location.lng()
                };
            
                const distanceToEnd = google.maps.geometry.spherical.computeDistanceBetween(
                    new google.maps.LatLng(currentCoords.lat, currentCoords.lng),
                    new google.maps.LatLng(stepEnd.lat, stepEnd.lng)
                );

                const distanceToStart = google.maps.geometry.spherical.computeDistanceBetween(
                    new google.maps.LatLng(currentCoords.lat, currentCoords.lng),
                    new google.maps.LatLng(stepStart.lat, stepStart.lng)
                );

                console.log("===>"+distanceToEnd+"---"+distanceToStart);

                // let distanceToNextStepStart = Infinity;
                //     if (next_step) {
                //         const nextStepStart = {
                //             lat: next_step.start_location.lat(),
                //             lng: next_step.start_location.lng()
                //         };
                //         distanceToNextStepStart = google.maps.geometry.spherical.computeDistanceBetween(
                //             new google.maps.LatLng(currentCoords.lat, currentCoords.lng),
                //             new google.maps.LatLng(nextStepStart.lat, nextStepStart.lng)
                //         );

                //         console.log("===>"+distanceToNextStepStart);
                //     }

            
                // Update the instructions with the remaining distance
                 displayNextInstruction(step,nextStep,nextNextStep, distanceToEnd);
            
                // Move to the next step if the distance to the end of the current step is less than a threshold
                const threshold = 45;
                if (distanceToEnd < threshold && distanceToEnd  < distanceToStart) {   
                    currentStepIndex++;
                    updateInstructions(currentStepIndex,distanceToEnd);
                }
            }

            function averageCoords(coordsArray) {
                const avgLat = coordsArray.reduce((sum, coord) => sum + coord.lat, 0) / coordsArray.length;
                const avgLng = coordsArray.reduce((sum, coord) => sum + coord.lng, 0) / coordsArray.length;
                return { lat: avgLat, lng: avgLng };
            }

            function displayNextInstruction(step,next_step ,nextNextStep,distanceToEnd) {

                    var  maneuver_img; 
                    var  next_maneuver_img;
                    const instructionsDiv = document.getElementById('instructions1');
                    const instructionsDiv2 = document.getElementById('instructions2');
                    const instructionsDiv3 = document.getElementById('instructions3');
                    

                    // if(step){
                        
                    //         textToImage(step.maneuver).then(value => {
                    //         instructionsDiv.innerHTML = "<span class='material-symbols-outlined' style='color:white';font-size:48px;>"+value+"</span>";
                           
                    //     });

                    // }
                    if(next_step){
                        textToImage(next_step.maneuver).then(value =>  {
                        instructionsDiv2.innerHTML = "<span class='material-symbols-outlined' style='color:white';font-size:48px;>"+value+"</span>";
                        
                        });
                    }else{
                        instructionsDiv2.innerHTML = "";
                    }
                    if(nextNextStep){
                        textToImage(nextNextStep.maneuver).then(value =>  {
                            instructionsDiv.innerHTML = "<div style=color:white;font-size:24px;>Then : </div> <span class='material-symbols-outlined' style='color:white';font-size:48px;>"+value+"</span>";
                        
                        });

                    }
                    else{
                        instructionsDiv3.innerHTML = '<p>No more steps.</p>';
                    }  

                    instructionsDiv3.innerHTML = `<div style='color:white';font-size:48px;>Remaining: ${Math.round(distanceToEnd)} meters </div>`;
                
            }
            
            function updateInstructions(stepIndex,distanceToEnd) {

                    var  maneuver_img; 
                    var  next_maneuver_img;
                    const instructionsDiv = document.getElementById('instructions1');
                    const instructionsDiv2 = document.getElementById('instructions2');
                    const instructionsDiv3 = document.getElementById('instructions3');

                if (stepIndex < steps.length) {
                    console.log("StepIndex-->"+ stepIndex);
                    const step = steps[stepIndex];
                    const next_step = steps[stepIndex+1]
                    const next_next_step = steps[stepIndex+2]


                    // textToImage(step.maneuver).then(value => {
                    //      instructionsDiv.innerHTML = "<span class='material-symbols-outlined' style='color:white';font-size:48px;>"+value+"</span>";
                    // });

                    if(next_step){
                            textToImage(next_step.maneuver).then(value =>  {
                            instructionsDiv2.innerHTML = "<span class='material-symbols-outlined' style='color:white';font-size:48px;>"+value+"</span>";     
                        });
                    }else{
                        instructionsDiv2.innerHTML = "";
                    }

                    if(next_next_step){
                        textToImage(next_next_step.maneuver).then(value => {
                         instructionsDiv.innerHTML = "<div style=color:white;font-size:24px;>Then : </div><span class='material-symbols-outlined' style='color:white';font-size:48px;>"+value+"</span>";
                    });
                    }else{
                        instructionsDiv.innerHTML ="";
                    }
                   
                } else {
                    instructionsDiv3.innerHTML = '<div style=color:white;font-size:24px;>You have reached your destination.</div>';
                }
            }

           async function textToImage(maneuver){
                var formated_value = "";
                var returnValue ="straight";

                if(maneuver.length >2){

                    formated_value = maneuver.replace("-","_");
                    returnValue = formated_value;


                    switch(formated_value)
                    {
                        case "keep_right":
                            returnValue = "turn_slight_right";
                            break;
                        case "keep_left":
                            returnValue = "turn_slight_left";
                            break;
                        case "uturn_right":
                            returnValue = "u_turn_right";
                            break;
                        case "uturn_left":
                            returnValue = "u_turn_left";
                            break;

                    }
                }
                return returnValue; 
            }

            exports.initMap = initMap;
        })((this.window = this.window || {}));
    </script>

    <style>
        html,
        body,
        .container {
            height: 100%;
            margin: 0;
            aspect-ratio: 1 / 1;
            border-radius: 50%;
            position: relative;
            flex: 1;
        }

      
        .semitransparent1{
            position: absolute;
            width:100%;
            margin-top: 2rem;
            width:100%;
            height:2rem;
            display: flex;
            justify-content: center;
            position: absolute;
            background-color: #007219a1;

        }

        .semitransparent2{
            position: absolute;
            margin-top: 4rem;
            width:100%;
            height:1rem;
            display: flex;
            justify-content: center;
            position: absolute;
            background-color: #007219a1;
        }

        .map {
            position: absolute;
            flex: 1;
            height: 100%;
            aspect-ratio: 1 / 1;
            background-color: black;
            border-radius: 50%;
        }

        .semi-circle {
            width: 100%;
            height: 2rem;
            display: flex;
            justify-content: center;
            position: absolute;
            background-color: #007219a1;
           
            }

       
        .material-symbols-outlined {
        font-variation-settings:
        'FILL' 0,
        'wght' 400,
        'GRAD' 0,
        'opsz' 24
        }

        #pac-input {
            position: absolute;
            background-color: #fff;
            font-family: Roboto;
            font-size: 15px;
            font-weight: 300;
            margin-left: 12px;
            padding: 0 11px 0 13px;
            text-overflow: ellipsis;
            width: 400px;
            }

        #pac-input:focus {
            position: absolute;
            border-color: #4d90fe;
        }


</style>

        
    </style>
</head>

<body>
<div class="container">
    <div id="map" class="map"></div>
    <div id="navigation" style="visibility: hidden;">
        <div id="instructions1" class="semi-circle"></div>
        <div id="instructions2" class="semitransparent1"></div>
        <div id="instructions3" class="semitransparent2"></div>
    </div>
    <div id="search" style="visibility: visible;">
        <input
            id="pac-input"
            class="controls"
            type="text"
            placeholder="Where To"/>
    </div>

</div>
</body>

</html>
